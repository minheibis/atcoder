# 069 - Colorful Blocks 2（★3）

## 問題
https://atcoder.jp/contests/typical90/tasks/typical90_bq

## 解き方
- Nのオーダーが10^18, Kのオーダーが10^9と大きいので、結構計算量が少ない方法で行う必要がある。O(sqrt(N))、O(K)あたりを目指したい。
- 最初から順番に処理を追っていくと、1つめのブロックはK色で塗ることができ、2つ目のブロックはK-1色で塗ることができる。3つ目のブロックは、1つ目と2つ目と違う色である必要があるので、K-2色で塗ることができる。4つ目のブロックも、2つ目と3つ目と違う色が必要なので、K-2色で塗ることができる。つまり、3つ目以降のブロックはK-2色で塗られる。N>=3(N=2の場合も含めることができるが)ならば、K(K-1)((K-2)^(N-2))通りとなる。
- MODをとりながら冪乗を計算していくのは、PythonではPow関数を用いれば計算できる。また、繰り返し2乗法を自前で実装しても良い。

- PythonのPow関数
  - base の exp 乗を返します; mod があれば、base の exp 乗に対する mod の剰余を返します (pow(base, exp) % mod より効率よく計算されます)。二引数の形式 pow(base, exp) は、冪乗演算子を使った base**exp と等価です。
  - https://docs.python.org/ja/3/library/functions.html#pow

- 繰り返し2乗法のイメージ
  - 3^10を計算する場合、10=2^3 + 2^1なので、
```math
3^{10} = {3}^{({2}^{3})} * {3}^{({2}^{1})}
```
  - 10=1010(2)(この数をnとする)なので、3を2乗、2乗としていく(この数をxとする)間に、nがbit列で1桁目を見て1だったら、求める答えにxをかけ、nを右シフトしていくことを繰り返す。


## 実装例
```
MOD = 10**9 + 7

def own_pow(x, n, m):
    ans = 1
    # n が 0 になるまで計算を続ける.
    while n:
        if n & 1: # bit列で考えた時の最後の数字が1の場合は、今保持しているxをかける.
            ans *= x
            ans %= m
        x *= x
        x %= m
        n >>= 1 # bit列を右シフトする.
    return ans

def solve():
    N, K = map(int, input().split())
    if N == 1:
        ans = K
    else:
        ans = (K * (K-1) * own_pow(K-2, N-2, MOD)) % MOD
    print(ans)

solve()
```

## 参考リンク
- \[競プロ]繰り返し2乗法【Java】【Python】
  - https://qiita.com/aja_min/items/3cf0109bce40550e0e33
- Python で繰り返し2乗法を書いてみた
  - https://note.com/keyem/n/n526ee14fe3de